# -*- coding:utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt

import map_interface as mif

g_flag_ref_line_begin = False
g_flag_ref_line_end = False
g_point_x = 0
g_point_y = 0
g_slide_window = 0


# def onMotion(event):
#   x=event.xdata
#   y=event.ydata
#   visible = ann.get_visible()
#   if event.inaxes == ax:
#     contain, _ = ref_line.contains(event)
#     if contain:
#       plt.plot(x,y,'ro')
#       ann.xy = (x,y)
#       ann.set_text(str(y))
#       ann.set_visible(True)
#     else:
#       if visible:
#         ann.set_visible(False)
#     event.canvas.draw_idle()

class MapModify:
  def __init__(self, fig):
    self.fig = fig
    self.get_ref_line_flag = False
    self.rect_x = 0
    self.rect_y = 0
    self.ref_line_dict = {}
    self.ref_line_list = []
    self.road_id_list = []
    self.road_id = 0
    self.ax = self.fig.gca()
    self.ann = self.ax.annotate("", xy=(0,0), xytext=(-50,50), textcoords="offset pixels", 
                      bbox=dict(boxstyle="round", fc='r'), arrowprops=dict(arrowstyle="<->"))
    self.ann.set_text("select point by drag")


  def onButtonPress(self, event):
    if event.button == 1: # 单击左键
      x = event.xdata
      y = event.ydata
      
      if self.get_ref_line_flag and len(self.ref_line_list)>0: # 选点结束
        self.ann.set_visible(False) # 关闭显示
        event.canvas.draw_idle()
        # save the point list to vect
        self.road_id = self.road_id + 1 # 增加一个新id
        self.road_id_list.append(self.road_id) # 添加到road_id_list
        self.ref_line_dict[self.road_id] = self.ref_line_list # 把 id:ref_line添加进地图字典
      
      if not self.get_ref_line_flag and len(self.ref_line_list)==0: # 选点开始
        self.ann.xy = (x,y)
        self.ann.set_visible(True)
        event.canvas.draw_idle()

      self.get_ref_line_flag = not self.get_ref_line_flag  # 每点击一次左键，flag翻转一次
    
    else: # 其他按键
      self.get_ref_line_flag = False
      self.ann.set_visible(False)
      event.canvas.draw_idle()
    
    return

  def onButtonRelease(self, event):
#    self.get_ref_line_flag = False
    return

  def onMotion(self, event):
    if self.get_ref_line_flag:
      print(event.xdata, event.ydata)
    return

  def connect(self):
    self.fig.canvas.mpl_connect('button_press_event', mm.onButtonPress)
    self.fig.canvas.mpl_connect('button_release_event', mm.onButtonRelease)
    self.fig.canvas.mpl_connect('motion_notify_event', mm.onMotion)
    return

"""##############################################
"""
if __name__ == "__main__":
  direct = "../data/GPS_info/"
  coordi_type = "gps_"
  namelist = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']

  """
  # read data from files
  """
  filename = coordi_type + "a" + ".txt" + ".txt"
  data = np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])

  for alphabet in namelist:
    filename = coordi_type + alphabet + ".txt" + ".txt"
    try:
      data1=np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])
    except IOError:
      print("file open failed")
      break
    
    if(data1.size!=0):
      data = np.concatenate((data, data1), axis=0)
    else:
      print("%s is empty file!" %(filename))
    
    print("now loading {}".format(filename))
  
  """
  # transfer from gps to xyz
  """
  xyz_map = data*111000 # need modified

  """################################################################################
  " matplot
  """

  fig = plt.figure("basic_map")
  ax = fig.gca()
#  ax = fig.add_subplot(111)
  ref_line, = plt.plot(xyz_map[:,0], xyz_map[:,1], 'o', picker=5)

  mm = MapModify(fig)
  mm.connect()
  
  plt.show()

++++++++++++++++++++++++++++++
# # -*- coding:utf-8 -*-

# import numpy as np
# import matplotlib.pyplot as plt
# import scipy.spatial as spt

# class ModifyMap:
#   def __init__(self, fig, gps_map):
#     self.map_tree = spt.KDTree(gps_map)
#     self.fig = fig
#     self.begin_point = ()
#     self.end_point = ()
#     self.road_id = 0
#     self.road_id_list = []
#     self.ref_line = []
#     self.ref_line_dict = {}
#     self.ax = self.fig.gca()
#     self.ann = self.ax.annotate("", xy=(0,0), xytext=(-50,50), textcoords="offset pixels", 
#                       bbox=dict(boxstyle="round", fc='r'), arrowprops=dict(arrowstyle="<->"))
#     self.button = 0
  
#   def onButtonPress(self, event):
#     if event.button == 1: # left click
#       x = event.xdata
#       y = event.ydata
#       # seek point
#       (dis, nearest_point_index) = self.map_tree.query((x, y))
#       self.nearest_points = self.map_tree.data[nearest_point_index]
#       # set point
#       if len(self.begin_point) == 0: # begin
#         self.begin_point = self.nearest_points
#         self.ann.xy = self.begin_point
#         self.ann.set_text("right click to repick start")
#         self.ann.set_visible(True)
#         event.canvas.draw_idle()
#         print("start")
#       else:
#         if len(self.end_point) == 0: # end
#           self.end_point = self.nearest_points
#           self.ann.xy = self.end_point
#           self.ann.set_text("right click to repick end")
#           self.ann.set_visible(True)
#           event.canvas.draw_idle()
#           print("end")
#         else: # save to vect
#           self.ann.xy = (event.xdata, event.ydata)
#           self.ann.set_text("save ref_line")
#           self.ann.set_visible(True)
#           event.canvas.draw_idle()
#           self.end_point = []
#           self.begin_point = []
#           #save data
#           print("save")
#     else: # right click
#       if len(self.end_point)>0:
#         self.ann.xy = self.begin_point
#         self.ann.set_text("repick the end point")
#         self.ann.set_visible(True)
#         event.canvas.draw_idle()
#         self.end_point = []
#         print("re_end")
#       else:
#         if len(self.begin_point)>0:
#           self.ann.set_visible(False)
#           event.canvas.draw_idle()
#           self.end_point = []
#           self.begin_point = []
#           print("re_start")

#   def onButtonRelease(self, event):
#     return
  
#   def callBackConnect(self):
#     self.fig.canvas.mpl_connect('button_press_event', self.onButtonPress)
#     self.fig.canvas.mpl_connect('button_release_event', self.onButtonPress)
#     return

#   def callBackDisconnect(self):
#     self.fig.canvas.mpl_disconnect('pick_event', self.onPick)
#     self.fig.canvas.mpl_disconnect('button_press_event', self.onButtonPress)
#     self.fig.canvas.mpl_disconnect('button_release_event', self.onButtonPress)
#     return

# """##############################################
# """
# if __name__ == "__main__":
#   direct = "../data/GPS_info/"
#   coordi_type = "gps_"
#   namelist = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']

#   """
#   # read data from files
#   """
#   filename = coordi_type + "a" + ".txt" + ".txt"
#   data = np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])

#   for alphabet in namelist:
#     filename = coordi_type + alphabet + ".txt" + ".txt"
#     try:
#       data1=np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])
#     except IOError:
#       print("file open failed")
#       break
    
#     if(data1.size!=0):
#       data = np.concatenate((data, data1), axis=0)
#     else:
#       print("%s is empty file!" %(filename))
    
#     print("now loading {}".format(filename))
  
#   """
#   # transfer from gps to xyz
#   """
#   xyz_map = data*111000 # need modified

#   """################################################################################
#   # matplot
#   # 1.对数据分两个维度分别进行排序
#   # 2.绘图
#   # 3.左键选起始点，右键取消
#   # 4.左键选结束点，右键取消
#   # 5.保存
#   """

#   fig = plt.figure("basic_map")

#   map_tree = spt.KDTree(xyz_map)
#   print(map_tree.data.shape)

#   x = xyz_map[:, 0]
#   y = xyz_map[:, 1] 
#   plt.plot(x, y, 'o')

#   map_mod = ModifyMap(fig, xyz_map)
#   map_mod.callBackConnect()

#   plt.show()

# -*- coding:utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import scipy.spatial as spt

class prepareData:
  def __init__(self, data_dir):
    self.data_dir = data_dir
    return
  
  def proceedMap(self):
    filename = self.data_dir + "map_point_data.csv"
    try:
      point_data = np.loadtxt(filename, delimiter=',')
      longi = point_data[:,0]
      lanti = point_data[:,1]
      longi_uni, index = np.unique(longi, return_index=True)
      lanti_uni = lanti[return_index]
    except IOError:
      print("cannot open file")
      return False
    return True

class ModifyMap:
  def __init__(self, fig, gps_map):
    self.map_tree = spt.KDTree(gps_map)
    self.fig = fig
    self.road_point = []
    self.road_point_id = 0
    self.road_point_id_list = []
    self.road_point_dict = {}
    self.road_point_list = []
    
    self.ax = fig.gca()
    self.annt_dict = {}
  
  def onPick(self, event):
    mousevent = event.mouseevent
    thisline = event.artist
    xdata = thisline.get_xdata()
    ydata = thisline.get_ydata()
    ind = event.ind
    points = tuple(zip(xdata[ind], ydata[ind]))

    if mousevent.button == 1: # if left_button pressed, add the point to road_point_list
      self.road_point = points[0] # get point
      self.road_point_id = self.road_point_id + 1 # set point_id
      self.drawPointID(self.road_point_id, self.road_point)
      print("{} points in the list".format(len(self.road_point_id_list)))

    else: # right select will delete the point
      road_point = self.getSamePoint(points, self.road_point_list)
      if road_point != 0:
        road_point_id = list(self.road_point_dict.keys()) [list(self.road_point_dict.values()).index (road_point)]
        self.destroyPointID(road_point_id)
      pass

    return

  def getSamePoint(self, list1, list2):
    list_a = [a for a in list1 if a in list2]
    if len(list_a)>0:
      return list_a[0]
    else:
      return 0

  def onButtonPress(self, event):
    # if event.button != 1:
    #   if len(self.road_point_id_list)>0:
    #     print("now {} point in list".format(len(self.road_point_id_list)))
    #     print("now id={}".format(self.road_point_id))
    #     self.road_point_id = self.road_point_id_list[-1]
    #     print("refresh id={}".format(self.road_point_id))
    #     self.destroyPointID(self.road_point_id)
    #     print("destroy id={}".format(self.road_point_id))
    #   else:
    #     print("no point in road_point_list")
    return

  def onKeyPress(self, event):
    if event.key == 'v':
      if self.road_id > 0:
        print("saving data to file")
    return

  def callBackConnect(self):
    self.fig.canvas.mpl_connect('pick_event', self.onPick)
    self.fig.canvas.mpl_connect('button_press_event', self.onButtonPress)
    self.fig.canvas.mpl_connect('key_release_event', self.onKeyPress)
    return

  def callBackDisconnect(self):
    self.fig.canvas.mpl_disconnect('pick_event', self.onPick)
    self.fig.canvas.mpl_disconnect('button_press_event', self.onButtonPress)
    self.fig.canvas.mpl_disconnect('key_press_event', self.onKeyPress)
    return

  def drawPointID(self, point_ID, road_point):
    # add the point/ID/annotate
    self.road_point_id_list.append(point_ID) 
    self.road_point_dict[point_ID] = road_point
    self.road_point_list.append(road_point) 
    plt.plot(road_point[0], road_point[1], 'ro')
    annt = ax.annotate("", xy=(0,0), xytext=(-20,20), textcoords="offset pixels", 
                      bbox=dict(boxstyle="round", fc='r'), arrowprops=dict(arrowstyle="-"))
    annt.set_text(str(point_ID))
    annt.xy = road_point
    annt.set_visible(True)
    self.annt_dict[point_ID] = annt
    self.fig.canvas.draw()

  def destroyPointID(self, point_ID):
    road_point = self.road_point_dict[point_ID]
    # remove the point/the id/annotate
    del(self.road_point_dict[point_ID])
    self.road_point_list.remove(road_point)
    self.road_point_id_list.remove(point_ID)
    if len(self.road_point_id_list)==0:
      self.road_point_id = 0
    else:
      self.road_point_id = self.road_point_id_list[-1]
    annt = self.annt_dict[point_ID]
    del(self.annt_dict[point_ID])
    annt.remove()
    plt.plot(road_point[0], road_point[1], 'bo') # overwrite the point
    self.fig.canvas.draw()

"""##############################################
"""
if __name__ == "__main__":
  direct = "../data/GPS_info/"
  coordi_type = "gps_"
  namelist = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']

  """
  # read data from files
  """
  filename = coordi_type + "a" + ".txt" + ".txt"
  data = np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])

  for alphabet in namelist:
    filename = coordi_type + alphabet + ".txt" + ".txt"
    try:
      data1=np.loadtxt(direct+filename, delimiter='\t', usecols=[1,2])
    except IOError:
      print("file open failed")
      break
    
    if(data1.size!=0):
      data = np.concatenate((data, data1), axis=0)
    else:
      print("%s is empty file!" %(filename))
    
    print("now loading {}".format(filename))
  
  """
  # transfer from gps to xyz
  """
  xyz_map = data*111000 # need modified

  """################################################################################
  # matplot
  # 1.对数据分两个维度分别进行排序
  # 2.绘图
  # 3.左键选起始点，右键取消
  # 4.左键选结束点，右键取消
  # 5.保存
  """


  map_tree = spt.KDTree(xyz_map)
  print(map_tree.data.shape)

  x = xyz_map[:, 0]
  y = xyz_map[:, 1] 
  fig = plt.figure()
  ax = fig.add_subplot(111)
  ax.set_title('modify map')
  orig_fig, = ax.plot(x, y, 'o', picker=5)

  map_mod = ModifyMap(fig, xyz_map)
  map_mod.callBackConnect()

  plt.show()

